1.什么是类？什么是对象？
  1)现实世界是由很多对象组成的
    基于对象抽出类
  2)对象:真实存在的单个的个体
    类:类型/类别，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征--------成员变量
    3.2)所有对象所共有的行为-------------方法
  4)一个类可以创建多个对象
    同一类型的多个对象，结构相同，数据不同
  5)类是对象的模板，对象是类的具体的实例


             引用       指向       对象
数据类型  引用类型变量
Student       zs          =      new Student();

0.方法的签名:方法名+参数列表
1.方法的重载(Overload):
  1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
  2)编译器在编译时根据方法的签名自动绑定调用的方法
2.构造方法:构造函数、构造器、构建器
  1)给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建(new)对象时被自动调用
  4)若自己不写构造方法，则编译器默认一个无参构造方法
    若自己写了构造方法，则编译器不再默认提供
  5)构造方法可以重载
3.this:指代当前对象，哪个对象调用方法它指的就是哪个对象
       只能用在方法中，方法中访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名---------访问成员变量
    2)this.方法名()-----------调用方法(一般不用)
    3)this()------------------调用构造方法
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能再进行任何操作了，
       若操作则发生NullPointerException空指针异常
5.引用类型变量画等号:
  1)指向同一个对象
  2)通过一个引用对数据的修改会影响另一个引用对数据的访问
    eg:房子钥匙
  基本类型变量画等号:
  1)赋值
  2)对一个变量的修改不会影响另一个变量的访问
    eg:身份证复印件


.继承:
  1)作用:代码复用
  2)通过extends来实现继承
  3)超类/父类:所有派生类所共有的属性和行为
    派生类/子类:派生类所特有的属性和行为
  4)派生类继承超类后，派生类具有:派生类的+超类的
  5)一个超类可以有多个派生类
    一个派生类只能有一个超类------单一继承
  6)继承具有传递性
  7)java规定:构造派生类之前必须先构造超类
    派生类中若没有调用超类的构造方法
    -------则默认super()调用超类的无参构造方法
    派生类中若调用了超类的构造方法
    -------则不再默认提供
    super()调用超类构造时必须位于派生类构造的第一行
3.super:指代当前对象的超类对象
  super的用法:
    1)super.成员变量名--------访问超类的成员变量
    2)super.方法名()----------调用超类的方法(明天讲)
    3)super()-----------------调用超类的构造方法

1.向上造型:
  1)超类型的引用指向派生类的对象
  2)能点出来什么，看引用的类型
2.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
  3)重写遵循"两同两小一大"原则:---------了解
    3.1)两同:
        3.1.1)方法名称相同
	3.1.2)参数列表相同
    3.2)两小:
        3.2.1)派生类方法的返回值类型小于或等于超类方法的
	      3.2.1.1)void时，必须相等
	      3.2.1.2)基本类型时，必须相等
	      3.2.1.3)引用类型时，小于或等于
	3.2.2)派生类方法抛出的异常小于或等于超类方法的------异常之后讲
    3.3)一大:
        3.3.1)派生类方法的访问权限大于或等于超类方法的------下次课讲
3.重写与重载的区别:-----------面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
    1.2)遵循"运行期"绑定，看对象的类型来调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
    2.2)遵循"编译期"绑定，看参数/引用的类型来绑定方法

1.package:
  1)作用:避免类的命名冲突
  2)包名可以有层次结构，同包中的类不能同名
  3)类的全称: 包名.类名
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问，
    不同包中的类不能直接访问，想访问只能如下方式:
    1.1)先import声明类再使用类----建议
    1.2)类的全称---------太繁琐，不建议
2.访问控制修饰符:
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、派生类、同包类
  4)默认的:什么也不写，本类、同包类
  说明:
    1)类的访问修饰只能是public或默认的
    2)类中成员的访问修饰如上4种都可以
3.final:最终的、不可改变的-----单独应用率低
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
4.static:静态的
  1)静态变量:
    1.1)由static修饰
    1.2)属于类，存储在方法区中，只有一份
    1.3)常常通过类名点来访问
    1.4)何时用:所有对象所共享的数据(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
    2.2)属于类，存储在方法区中，只有一份
    2.3)常常通过类名点来访问
    2.4)静态方法没有隐式的this传递，
        静态方法中不能直接访问实例成员
    2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)属于类，在类被加载期间自动执行，
        因类只被加载一次，所以静态块只执行一次
    3.2)何时用:加载/初始化静态资源(图片、音频、视频)


1.static final常量: 应用率高
  1)必须声明同时初始化
  2)通过类名点来访问，不能被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时将常量直接替换为具体的值，效率高
  5)何时用:数据永远不变，并且经常使用
2.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有具体的实现(连{}都没有)
3.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类----我乐意
  3)抽象类不能被实例化
  4)抽象类是需在被继承的，派生类:
    4.1)重写所有抽象方法------常用
    4.2)也声明为抽象类--------不常用
  5)抽象类的意义:
    5.1)封装共有的属性和行为-----------代码复用
    5.2)为所有派生类提供统一的类型-----向上造型
    5.3)可以包含抽象方法，为所有派生类提供统一的入口
        派生类的具体行为不一样，但入口是一致的


1.成员内部类:应用率低，了解
  1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常只在外部类中创建
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有隐式的引用指向了创建它的外部类对象
      eg: 外部类名.this.
2.匿名内部类:
  1)若想创建一个类(派生类)的对象，并且对象只被创建一次，
    此时该类不必命名，称为匿名内部类
  2)匿名内部类中若想访问外面的变量，该变量必须是final的(JDK1.7(含)以前)


1.接口:
  1)是一种数据类型(引用类型)
  2)由interface定义
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/派生类:
      必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口


设计规则:
1)将所有派生类所共有的属性和行为，抽到超类中-----抽共性
2)所有派生类的行为都一样，设计普通方法
  所有派生类的行为都不一样，设计为抽象方法
3)将部分派生类所共有的行为，抽到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展---------实现多继承


接口的好处---------明天下午


1.内存管理:由JVM管理的------------了解
  1)堆:
    1.1)存储new出来的对象(包括实例变量)
    1.2)垃圾:没有任何引用所指向的对象
        垃圾回收器(GC)不定时到内存中清扫垃圾
	回收过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，
	调用System.gc()可以建议JVM尽快调度GC来回收
	回收对象时，实例变量一并被回收
    1.3)实例变量的生命周期:
          创建对象时存储在堆中，对象被回收时一并被回收
    1.4)内存泄漏:不再使用的对象还没有被及时的回收
        建议:对象不再使用时，及时将引用设置为null
  2)栈:
    2.1)存储正在调用方法中的局部变量(包括方法的参数)
    2.2)调用方法时会在栈中为该方法分配一块对应的栈帧，
        栈帧中存储方法中的局部变量(包括参数)，
	方法调用结束时，栈帧被清除，局部变量一并被清除
    2.3)局部变量的生命周期:
          调用方法时存储在栈中，方法结束与栈帧一并被清除
  3)方法区:
    3.1)存储.class字节码文件(包括方法、静态变量)
    3.2)方法只有一份，通过this来区分具体的调用对象



总结:
面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性和行为
  2)方法:封装特定的业务逻辑功能实现
  3)访问控制修饰符:封装的是具体的访问权限
2.继承:
  1)作用:代码复用
  2)超类:所有派生类所共有的属性和行为
    接口:部分派生类所共有的行为
    派生类:派生类所特有的属性和行为
  3)传递性，单一继承，多接口实现
3.多态:
  1)意义:行为的多态(所有抽象方法都是多态的)
         对象的多态(所有对象都是多态的)
  2)向上造型、强制类型转换、instanceof判断
  3)多态的表现形式:
    3.1)重写:根据对象的不同来表现多态
    3.2)重载:根据参数的不同来表现多态













